__init__.py  он помогает работать с дирректориями как с пакетами
с поомщтб  него мы модем указать какие именно функции и модули мы указываем для импорта прямо из директории. при наличии файла main.py в котором есть например 2 функции которые выводят какой нибудь результат, но когда проект будет разрастаться и вмещать все в один файл это будет не совсем так сказать комильфо. и при распределении этих функций по отдельным характеризующих эти функции файлов то нам нужно будет применить импорты которые будут стекаться в один файл main.py,например в файле main.py будут указаны импорты так: from circle import circle_def и from square import square_def и circle_def()  square_def(), и вызываем их в main.py. и автоматически при запуске кода будет создана папка __pycache__. при запуске кода python компилирует py файлы в py c в байт код и сохраняет папку pycache,это делаеться для ускорения повторных запусков.оно особо не влияет,можно удалить,можно не удалять. но если проект все разрастаеться и появляеться еще с десяток таких файлов и зранить из внутри главной директории вместе с main file-это есть не очень целесообразно и мы создаем папку(пакет) в котором будут храниться файлы,например папку utils.До версии python 3.3,нужно было создавать файл __init__.py для того чтобы python точно понял что та директория,та папка в котором зраняться наши файлы - это пакет,а не чтото другое,но сейчас в этом необходимости какой-то нет,если мы перенесем файлы в папку и запустим код уже в ней,то файл pycаche создадить еще и внутри этой папки. но если мы запустим код в файле main.py, который находиться на одном уровне с папкой utils, то путь внутри файла main к функциям измениться,там будет добавлено имя папки в которой они лежат,то есть абсолютный путь, потому что файл main.py он не видит эти файлы circle.py и square.py, потому что они лежат в папке а не находяться на одном уровне с файлом main.py, вот так:

utils
    square.py
    circle.py
main.py
и тут проявляеться сила структуры,потому что если мы начинаем делить код по смыслу- то python с этим отлично справляеться,если мы запускаем все из корня из main.py, но когда все становиться сложнее или я хочу использовать вложенные импорты,то просто разьросать py.файлы по дирректориям уже будет недостаточно и нам нудно указывать для python, что вот эта самая папка - это часть проекта. помимо того что init файл - это своего рода маркер того что дирректория являеться на самом деле пакетом и ее можно импортировать как единое целое, он еще и выполняеться при первом импорте пакета и с помощью него я могу сама настроить какие именно функции и модули могут быть доступны при импорте. если создать файл init и внести туда строку например print("heloo!"), и при запуске кода в main.py- это будет первое что выведиться в терминале.
если мы в main.py впишем импорт  from folder(папка) import square_def, то есть не так: from folder.square import square_def а вот так: from folder import square_def - то будет ошибка потому что Python не сможет её найти и тут мы открываем файл init  и вносим в него запись: from .square import square_def .и обязательно с точкой,почему,потому что при запуске кода который лежит на другом уровне мы уже будем находиться внутри пакета с этими файлами,потому что внутри init.py мы уже находимся внутри пакета, и python ищет square.py в корне проекта, а его там нет,потому чтоон в пакете,   и чтобы импортировать из текущего пакета, нужно прописать путь относительный, то есть просто добавить точку: from .square import square_def.  и возвращаясь в main, при запуске кода: 
from folder import square_def 

square_def()

либо from folder import * и все будет работать. __init__.py -это точка входа в наш пакет и мы можем решать что нам важно и что мы оставляем снаружи и что внутри и для опрятности кода тоже . тоже самое и с обычными библиотеками которые мы импортируем для функционала нашего кода, например numpy, там уже все укомплектовани и рассортировано и записано в файле init.  и на счет поведения,если нужно контролировать поведение, нужно включить метод __all__ и включить в него список того что мы хотим импортировать,например __all__("square_def", "square_def1"). если без __all__, то python будет импортировать все что есть в файле,а вместе с __all__ мы сами указываем на то,что нужно вытащить,плюс если есть какието ненудные для нас функции и чтобы их не тянуть за собой. в __init__ файле также зраняться глобальные  переменные. но если мы добавляем эту переменную в __init__ , то и в all метод нам тоже нужно ее добавить. также когда функционал наших square.py и circle.py файлов растет и нужно из распределить по  отдельным папкам и если будет требование чтобы функционал одного файла был включен в другом файле, 