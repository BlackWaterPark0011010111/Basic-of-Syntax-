Сам пк работает с электрическими сигналами.ток либо есть либо нет. 0 ли 1,если переводить в математический язык,так вот 0 и 1 называется битом,но одного бита слишком мало чтобы чтото выразить,поэтому
поэтому биты собираются в кучу из 8-ми штук,которая называется байтом.То есть байт это клетка,которая собирает в себе  8 битов. и каждый бит,он как лампочка,он может быть либо включен либо выключен, то есть либо 0 либо 1.
и комбинация подобного означает то,что мы можем закодировать что угодно-- и это кодировка.
Соглашение ASCII.

Когда мы работаем со строкой например,то мы  всегда работаем с абстракцией,с самой идеей текста. 
и сами байты и биты мы не видим,но внутри памяти это чтобы мы не задавали,эта строка будет выглядеть только через набор этих битов которые содержат эти байты внутри себя.и если мы хотим или нам нужно работать с этими самыми байтами,с этой голой последовательностью байтов,нужно использовать особенные типы данных как bytes и bytearray.
Сам тип bytes, он понятно что не изменяемый,то есть это неизменяемая последовательность байтов.
создать обьект bytes можно например из последовательности,то есть мы создаем сами байтовый обьект из чисел,которые отоюражают соответствие латинским буквам в ASCII кодировке H E L L O, и он будет показывать их нам в читаемой форме.:
b=bytes([72,101,108,108,111])
print(b)---->будет 'Hello'
Это просто представление для нашего собственного удобства,но внутри будут лежать все те же числа.
И изменить их мы никак не сможем,в плане как например заменить  первый обьект на другой b[0]=4.Bytes - неизменяем как строка или кортеж,и это делает его безопасным для использования в качестве ключа. Байты всплываюткогда мы читаем данные из файла в режиме 'rb' или из сети через сокеты,из сериализованных обьектов,то есть это самые сырые и неинтерпретированные данные. 
А bytearray уже как раз изменяемая последовательность байтов,это уже будет как список,но только для чисел от 0 и до 255, 2 в 8 cтепени минус 1. То есть мы в нем можем,менять,добавлять и удалять елементы. 
ba = bytearray([72, 101, 108, 108, 111])
print(ba)----->будет Hello
и тут уже можно изменять 
ba[0] = 65  ------> буква А
print(ba) ---->bytearray(b'Aello')
Но если например нам нужно превратить в байты строку,то тут нужна кодировка. Это правило,которое говорит по себе,что и как именно преобразовать,какой символ в последовательность байтов.
text = "Привет, мир!"
byte_data = text.encode('utf-8') ---> здесь переводим в байты но в будут показаны в шестнадцатеричном виде,и при чем если есть запятые,точки,пробелы и остальные символы,они будут отображаться без изменений.потому что для них в utf-8 байт совпадает с ASCII.

new_text = byte_data.decode('utf-8')--->
И теперь мы обратно декодируем utf-8 в строку.
print(new_text) 
и если попытаться закодировать с неверной кодировкой ,то будет либо ошибка либо чтото совсем невразумительное.

если мы работаем с элементом по индексу,получим
целое число от 0 до 255.
а если делается срез,например есть строка data=b'Hello world', и мы выбираем print(data[0:5]),то выведет Hello.и для bytearray доступны все методы что в списках


отличие bytearray от bytes в том что bytearray изменяемый тип данных а  bytes нет
bytearray это последовательность интов.
в python2 то что ранее было строкой а теперь в python3 называется bytes. и ранее строки были битовые а теперь юникодные
потому что в python2 был отдельный тип unicode, а в python3 уже называется str. И unicode object - это все еще строка

ord('=')чтобы узнать какое по порядку символ =

(61).to_bytes()
int.from_bytes(b'\x3d') hex символ 61
oct(61)  восьмеричная запись

b'=' == b'\x3d' == b'\075' ---> True

b'='.decode('ascii')  --->True
b'\x3d'.decode('ascii')  --->True
b'\075'.decode('ascii')  --->True

Значение 127- это последнее значение которое можно записать внутри байт как обычный символ и последующие значение уже будут как hex.


                      