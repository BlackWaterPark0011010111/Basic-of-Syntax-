Сам пк работает с электрическими сигналами.ток либо есть либо нет. 0 ли 1,если переводить в математический язык,так вот 0 и 1 называется битом,но одного бита слишком мало чтобы чтото выразить,поэтому
поэтому биты собираются в кучу из 8-ми штук,которая называется байтом.То есть байт это клетка,которая собирает в себе  8 битов. и каждый бит,он как лампочка,он может быть либо включен либо выключен, то есть либо 0 либо 1.
электричество → 0/1 → бит → байт → кодировка → bytes → bytearray → encode/decode → сеть

и комбинация подобного означает то,что мы можем закодировать что угодно-- и это кодировка.
Соглашение ASCII,таблица соответствия.

Когда мы работаем со строкой например,то мы  всегда работаем с абстракцией,с самой идеей текста. 
и сами байты и биты мы не видим,но внутри памяти это чтобы мы не задавали,эта строка будет выглядеть только через набор этих битов которые содержат эти байты внутри себя.и если мы хотим или нам нужно работать с этими самыми байтами,с этой голой последовательностью байтов,нужно использовать особенные типы данных как bytes и bytearray.
Сам тип bytes, он понятно что не изменяемый,то есть это неизменяемая последовательность байтов.
создать объект bytes можно например из последовательности,то есть мы создаем сами байтовый обьект из чисел,которые отображают соответствие латинским буквам в ASCII кодировке H E L L O, и он будет показывать их нам в читаемой форме.:
b=bytes([72,101,108,108,111])
print(b)---->будет 'Hello'
Это просто представление для нашего собственного удобства,но внутри будут лежать все те же числа.
И изменить их мы никак не сможем,в плане как например заменить  первый объект на другой b[0]=4. Bytes - неизменяем как строка или кортеж,и это делает его безопасным для использования в качестве ключа. Байты всплывают когда мы читаем данные из файла в режиме 'rb' или из сети через сокеты,из сериализованных объектов,то есть это самые сырые и неинтерпретированные данные. 
А bytearray уже как раз изменяемая последовательность байтов,это уже будет как список,но только для чисел от 0 и до 255(атомарный уровень), 2 в 8cтепени минус 1. То есть мы в нем можем,менять,добавлять и удалять елементы. 
ba = bytearray([72, 101, 108, 108, 111])
print(ba)----->будет Hello
и тут уже можно изменять 
ba[0] = 65  ------> буква А
print(ba) ---->bytearray(b'Aello')
Но если например нам нужно превратить в байты строку,то тут нужна кодировка. Это правило,которое говорит по себе,что и как именно преобразовать,какой символ в последовательность байтов.
text = "Привет, мир!"
byte_data = text.encode('utf-8') ---> здесь переводим в байты но в будут показаны в байтовом представлении,которое python печатает в hex для непечатаемых символов и при чем если есть запятые,точки,пробелы и остальные символы,они будут отображаться без изменений.потому что для них в utf-8 байт совпадает с ASCII.

new_text = byte_data.decode('utf-8')--->
И теперь мы обратно декодируем utf-8 в строку.
print(new_text) 
и если попытаться закодировать с неверной кодировкой ,то будет либо ошибка либо что-то совсем невразумительное.

если мы работаем с элементом по индексу,получим
целое число от 0 до 255.
а если делается срез,например есть строка data=b'Hello world', и мы выбираем print(data[0:5]),то выведет Hello.и для bytearray доступны все методы что в списках.





Все данные предаваемые по сети через библиотеки socket,requests,aiohttp- это будут потоки байтов.мы отправляем байты и получаем их в ответ. и json ответ получаем от сервера приходит в виде байтов,которые потом декодируются в строку и потом нужно распарсить.
socket например это низкоуровневая библиотека и она не знает что это за байты которые мы передаем,она если видит байт со значением 72-то для нее это просто 72 и если я использую  что-то высокоуровневое,например request запрос на сайт,то эта библиотека формирует http запрос,который является текстовой командой,кодирует его в байты,отправляет по сокету и получает в ответ поток байтов. и тут она должна понять где в этом потоке заканчиваются заголовки ответа и начинается само тело.она смотрит на байты,находит последовательности,например \r\n\r\n--это для переноса строки,маркер конца заголовка http,и разделяет поток,смотрит на заголовок,к примеру(Content-Type: application/json; charset=utf-8),тут можно увидеть,что тело ответа json  и плюс он закодирован в utf-8,значит нужно декодировать в строку с decode(utf-8) и результат(строка) передать парсеру json,который превратит её обратно в высокоуровневые python -объекты,все от начала и до самого response.json() 




криптография
Порядок байтов в криптографии очень важен(endianness).если мы работаем с числами занимающими более одного байта,например целые 32-битные числа,то они могут быть представлены в памяти и в потоке данных в разном порядке,от младшего к старшему(little-endian,как в x86,то есть наименее значимый байт числа идет первым и такой порядок использует архитектура процессов x86-64,то есть все современные процессоры в персональных пк и серверах) или от старшего к младшему(big-endian,сетевой порядок,то есь тут самый значимый байт числа идет первым в последовательности и такой порядок считается естественным дял чтения для самого человека,то есть сначала сотни,потом десятки,потом единицы,и так он был принят как сетевой порядок network byte order(исторически) в стандарте интернета,как в заголовках  TCP\IP). Потому что когда мы получаем откуда-то поток байтов,в котором закодированы числа,я должна знать в каком порядке они идут(байты). и если я прочитаю первые 2 байта([52, 18]) и интерпретирую их как 16-битное число в формате процессора little-endian,то я получу совсем не то значение что задумывалось,если отправитель использовал big-endian.

и модуль struct используется здесь как раз для упаковки и распаковки таких структур составных в объекты bytes и обратно, мы задаем формат строки и struck.pack превращает число в последовательность из 4х байтов,уложенных в правильном порядке для сети или файлового формата.struck.unpack --извлекает число из 4х байтов.
вообще работа с bytes и bytearray часто сопровождается использованием struct,для интерпретации участков памяти как чисел со своей разрядностью и форматом.
при работе с большими объемами данных(аудио,видео и тд...) использование bytearray и операций с памятью через memoryview.memoryview дает представление о данных внутри bytes  или bytearray без копий. тут происходит обращение к  срезу огромных массивов байтов, интерпретация через struct без расходов на копирование данных. memoryview бущет служить инструментом для взаимодействия с бинарными данными без копий,а это важно для высокопроизводительности и для подобных приложений.
Для сериализации бинарных протоколов,кроме struct,для сложных форматов есть библиотеки protobuf,msgpack,flatbuffers.Они превращают словари,списки в плотную сжатую пачку байтов,двоичный формат и это не то что можно прочесть своими глазами, и итог для ихней работы будет  объект bytes, готовая пачка байтов для отправки или сохранения.

Если взять хеш-функцию SHA-256, эта функция про битовые последовательности и если мы вычисляем хеш пароля,то мы передаем функции hashlib.sha256 объект bytes.Строку "мой_пароль" - нужно превратить в байты(b'мой_пароль') и это будет вызывать encode с дефолтной кодировкой и эти байты функция переламывает через математические сдвиги,превращая в последовательность байтов фиксированной длинны,в хеш. и этот хеш тоже байтовый(bytes).Здесь битовая точность очень важна,изменение одного бита в исходном сообщении,например смена регистра,он полностью до неузнаваемости меняет выходной хеш. и поэтому нужно оперировать байтами.
   
        
Производительность в bytearray. 
При написании TCP-прокси,который принимает поток байтов,чтото в нем поменять и переслать дальше и тут использовать неизменяемый bytes нельзя ,изза сохранения памяти и скорости,потому что при модификации нужно будет создавать новый обьект скопировав все данные,а bytearray позволит работать с одним и тем же куском памяти,как с глиной,и с методами find(),replace() и append() работают прямо на месте.  
TODO: щдесь продолжить с последним результатами что выдало про безопасность  и дописать с чнм работает ord
           
Различие между str bytes- в python 2 смешение строк и байтов было источником багов особенно при работе с ASCII текстом.и те ошибки которые я ранее упоминала,это было одним из этого. то есть это было следствием того,что программа неявно переводила байты в строки(гдето в глубине) или наоборот,предполагая кодировку по умолчанию.в Python3 провели границу,str- это будет текст(unicode),а bytes- это будут данные. и текста без кодировки не существует и данные без кодировки не текст. и encode/decode- в своем роде шлюзы между этими двумя мирами       
       





     
отличие bytearray от bytes в том что bytearray изменяемый тип данных а  bytes нет
bytearray это последовательность интов.
в python2 то что ранее было строкой а теперь в python3 называется bytes. и ранее строки были битовые а теперь юникодные
потому что в python2 был отдельный тип unicode, а в python3 уже называется str. И unicode object - это все еще строка

ord('=')чтобы узнать какое по порядку символ =

(61).to_bytes()
int.from_bytes(b'\x3d') hex символ 61
oct(61)  восьмеричная запись

b'=' == b'\x3d' == b'\075' ---> True

b'='.decode('ascii')  --->True
b'\x3d'.decode('ascii')  --->True
b'\075'.decode('ascii')  --->True

Значение 127- это последнее значение которое можно записать внутри байт как обычный символ и последующие значение уже будут как hex.


                      