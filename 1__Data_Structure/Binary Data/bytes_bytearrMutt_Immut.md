Сам пк работает с электрическими сигналами.ток либо есть либо нет. 0 ли 1,если переводить в математический язык,так вот 0 и 1 называется битом,но одного бита слишком мало чтобы чтото выразить,поэтому
поэтому биты собираются в кучу из 8-ми штук,которая называется байтом.То есть байт это клетка,которая собирает в себе  8 битов. и каждый бит,он как лампочка,он может быть либо включен либо выключен, то есть либо 0 либо 1.
электричество → 0/1 → бит → байт → кодировка → bytes → bytearray → encode/decode → сеть

и комбинация подобного означает то,что мы можем закодировать что угодно-- и это кодировка.
Соглашение ASCII,таблица соответствия.

Когда мы работаем со строкой например,то мы  всегда работаем с абстракцией,с самой идеей текста. 
и сами байты и биты мы не видим,но внутри памяти это чтобы мы не задавали,эта строка будет выглядеть только через набор этих битов которые содержат эти байты внутри себя.и если мы хотим или нам нужно работать с этими самыми байтами,с этой голой последовательностью байтов,нужно использовать особенные типы данных как bytes и bytearray.
Сам тип bytes, он понятно что не изменяемый,то есть это неизменяемая последовательность байтов.
создать обьект bytes можно например из последовательности,то есть мы создаем сами байтовый обьект из чисел,которые отоюражают соответствие латинским буквам в ASCII кодировке H E L L O, и он будет показывать их нам в читаемой форме.:
b=bytes([72,101,108,108,111])
print(b)---->будет 'Hello'
Это просто представление для нашего собственного удобства,но внутри будут лежать все те же числа.
И изменить их мы никак не сможем,в плане как например заменить  первый обьект на другой b[0]=4.Bytes - неизменяем как строка или кортеж,и это делает его безопасным для использования в качестве ключа. Байты всплываюткогда мы читаем данные из файла в режиме 'rb' или из сети через сокеты,из сериализованных обьектов,то есть это самые сырые и неинтерпретированные данные. 
А bytearray уже как раз изменяемая последовательность байтов,это уже будет как список,но только для чисел от 0 и до 255, 2 в 8 cтепени минус 1. То есть мы в нем можем,менять,добавлять и удалять елементы. 
ba = bytearray([72, 101, 108, 108, 111])
print(ba)----->будет Hello
и тут уже можно изменять 
ba[0] = 65  ------> буква А
print(ba) ---->bytearray(b'Aello')
Но если например нам нужно превратить в байты строку,то тут нужна кодировка. Это правило,которое говорит по себе,что и как именно преобразовать,какой символ в последовательность байтов.
text = "Привет, мир!"
byte_data = text.encode('utf-8') ---> здесь переводим в байты но в будут показаны в байтовом представлении,которое python печатает в hex для непечатаемых символов и при чем если есть запятые,точки,пробелы и остальные символы,они будут отображаться без изменений.потому что для них в utf-8 байт совпадает с ASCII.

new_text = byte_data.decode('utf-8')--->
И теперь мы обратно декодируем utf-8 в строку.
print(new_text) 
и если попытаться закодировать с неверной кодировкой ,то будет либо ошибка либо чтото совсем невразумительное.

если мы работаем с элементом по индексу,получим
целое число от 0 до 255.
а если делается срез,например есть строка data=b'Hello world', и мы выбираем print(data[0:5]),то выведет Hello.и для bytearray доступны все методы что в списках.





Все данные предаваемые по сети через библиотеки socket,requests,aiohttp- это будут потоки байтов.мы отправляем байты и получаем их в ответ. и json ответ получаем от сервера приходит в виде байтов,которые потом декодируются в строку и потом нужно распарсить.
socket например это низкоуровневая библиотека и она не знает что это за байты которые мы передаем,она если видит байт со значением 72-то для нее это просто 72 и если я использую  чтото высокоуровневое,например request запрос на сайт,то эта библиотека формирует http запрос,который я вляется текстовой командой,кодирует его в байты,отправляет по сокету и получает в ответ поток байтов. и тут она должна понять где в этом потоке заканчиваются заголовки ответа и начинается само тело.она смотрит на байты,находит последовательности,например \r\n\r\n--это для переноса строки,маркер конца заголовка http,и разделяет поток,смотрит на заголовок,к примеру(Content-Type: application/json; charset=utf-8),тут можно увидеть,что тело ответа json  и плюс он закодирован в utf-8,значит нужно декодировать в строку с decode(utf-8) и результат(строка) передать парсеру json,который превратит её обратно в высокоуровневые python -обьекты,все от начала и до самого responce.json() 


Потом на тему паролей,если взять хеш-функцию SHA-256, эта функция про битовае последовательности и если мы вычисляем зеш пароля,то мы передаем функции hashlib.sha256 обьект bytes.Строку "мой_пароль" - нужно первратить в байты(b'мой_пароль') и это будет вызывать encode с дефолтной кодировкой и эти байты функция переламывает через математические сдвиги,превращая в последовательность байтов фиксированной длинны,в хеш. и этот хеш тоже байтовый(bytes).Здесь битовая точность очень важна,изменение одного бита в исходном сообщении,например смена регистра,он полностью до неузнаваемости меняет выходной хеш. и поэтому нужно оперировать байтами.

Производительность в bytearray.
При написании TCP-прокси,который принимает поток




отличие bytearray от bytes в том что bytearray изменяемый тип данных а  bytes нет
bytearray это последовательность интов.
в python2 то что ранее было строкой а теперь в python3 называется bytes. и ранее строки были битовые а теперь юникодные
потому что в python2 был отдельный тип unicode, а в python3 уже называется str. И unicode object - это все еще строка

ord('=')чтобы узнать какое по порядку символ =

(61).to_bytes()
int.from_bytes(b'\x3d') hex символ 61
oct(61)  восьмеричная запись

b'=' == b'\x3d' == b'\075' ---> True

b'='.decode('ascii')  --->True
b'\x3d'.decode('ascii')  --->True
b'\075'.decode('ascii')  --->True

Значение 127- это последнее значение которое можно записать внутри байт как обычный символ и последующие значение уже будут как hex.


                      