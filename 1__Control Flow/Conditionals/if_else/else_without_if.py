
 else в циклах (for/while) — работает только если цикл НЕ прервался через break
 Когда пишешь else после цикла (for или while), этот блок выполняется только если цикл завершился "естественно", то есть без break.
 Как это работает на примере for-else
 for i in range(5):  # перебираем числа 0, 1, 2, 3, 4
     if i == 3:      # если нашли 3 — прерываем цикл
         break
     print(i)        # печатаем текущее число
 else:               # этот `else` относится к `for`, а не к `if`!
     print("цикл завершился без break")
 Что произойдет:
 Если i становится 3 → срабатывает break → else не выполняется.
 Если убрать if i == 3 → цикл пройдет все числа → else выполнится.
 Пример с while-else
 count = 0
 while count < 5:
     print(count) 
     if count == 2:
         break  # прерываем цикл
     count += 1
 else:
     print("цикл завершился без break")
 Если count достигает 2 → break → else не сработает.
 Если убрать break → цикл дойдет до count = 4 → else выполнится.
 Зачем это нужно?
 Раньше писали так (с флагом):
 found = False
 for item in items:
     if item == "ключ":
         found = True
         break
 if not found:
     print("ключ не найден")
 С for-else код становится короче:
  
 for item in items:
     if item == "ключ":
         break
 else:
     print("ключ не найден")
 2. else в try-except — выполняется, если не было ошибки
 В конструкции try-except блок else работает только если в try не произошло исключения.
 Пример с делением числа
  
 try:
     x = int(input("Введи число: "))
     result = 10 / x  # делим 10 на введенное число
 except ValueError:
     print("Это не число!")
 except ZeroDivisionError:
     print("На ноль делить нельзя!")
 else:
     print(f"Результат: {result}")  # сработает, если не было ошибок
 Как это работает:
 Если ввести букву → сработает except ValueError.
 Если ввести 0 → сработает except ZeroDivisionError.
 Если ввести корректное число (например, 2) → выполнится else.
 Зачем это нужно?
 Без else пришлось бы писать так:
  
 try:
     x = int(input("Введи число: "))
     result = 10 / x
     print(f"Результат: {result}")  # код после успешного выполнения
 except ValueError:
     print("Это не число!")
 Но если в try много действий, else помогает отделить основную логику от обработки ошибок.
 3. else в тернарном операторе (это не совсем else без if)
 В видео упоминалась запись условия в одну строку:
  
 result = "Четное" if x % 2 == 0 else "Нечетное"
 Это сокращенная замена if-else, но технически здесь есть условие (if).
 Выводы
 else без if в   работает только:
 В циклах (for/while) → выполняется, если не было break.
 В try-except → выполняется, если не было ошибки.
 Зачем это нужно? Упрощает код (избавляет от флагов в циклах).
 Позволяет четко разделить "успешный сценарий" и "обработку ошибок".
 Когда else не сработает?
 В циклах — если был break.
 В try-except — если было исключение.
 Пример из видео с try-except-else:
  
 try:
     num = int(input("Введи число: "))
     print(10 / num)
 except ZeroDivisionError:
     print("Делить на ноль нельзя!")
 else:
     print("Всё ок, ошибок не было!")   и    в циклах else вызываеться тогда когда не было вызвано конструкции с break 
 for i in range(10):
     if i > 5:
         break
     print(i)
 else:
     print("There was no break")
то есть else проверяет был ли вызван break или нет, если break  ьыл вызван то else не вызываеться
 основная идея видео в том что в питоне можно использовать else без if в двух случаях первый это с циклами for и while где else срабатывает только если не было break второй случай это с конструкцией try-except где else выполняется если не произошло исключения давай разберем оба варианта подробно
 когда ты пишешь else после цикла этот блок выполнится только если цикл завершился естественным путем без break представь что break это экстренный выход а else это награда за терпение за то что дошел до конца например вот код из видео:
 for i in range(10):
 if i > 5:
 break
 print(i)
 else:
 print("не было break")
 здесь цикл прерывается на i=6 поэтому else не выполнится если бы break не было else бы сработал после завершения цикла тоже самое с while:
 a = 0
 while a < 10:
 if a == 5:
 break
 print(a)
 a += 1
 else:
 print("не было break")
 второй случай это try-except-else здесь else работает как "все прошло без ошибок" например:
 try:
 x = int(input("введи число: "))
 except ValueError:
 print("это не число")
 else:
 print("число корректное:", x)
 если ввести буквы сработает except если цифры сработает else причем else выполнится только если не было ошибки в try блоке
 еще в видео упоминают что можно писать условные выражения в одну строку через тернарный оператор типа:
 result = "все ок" if условие else "все плохо"
 это аналог if-else но записанный компактно однако это не совсем else без if а просто другая форма записи
 главное что нужно запомнить else без if работает только:
 в циклах (срабатывает если не было break)
 в try-except (срабатывает если не было ошибки)
 во всех остальных случаях else всегда требует if